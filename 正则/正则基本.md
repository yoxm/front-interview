# 正则表达式的基本知识

一个前端菜菜鸟，每次遇到关于正则的问题总是搪塞过去，并没有对这个地方做一个系统的归纳总结。现在准备狠下心，做一个小小的归纳总结。

> 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法

## 基本知识

我们创建一个正则表达式在 js 中通常有 2 种方法，如下所示：

```javascript
const reg = /hello/;
const reg = /^[a-zA-Z]+[0-9]*\W?_$/gi;
```

或者用创建正则表达式的对象

```javascript
let regex = new RegExp("hello");

let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, "gi");
```

我们先给正则中的字符分一下类

* 普通字符
* 非打印字符
* 特殊字符
* 限定符

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符 | 描述                                                                                                                                                     |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。                              |
| ()   | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。                                                          |
| \*   | 匹配前面的子表达式零次或多次。要匹配 \* 字符，请使用 \*。                                                                                                |
| +    | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。                                                                                                 |
| .    | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。                                                                                                |
| [    | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。                                                                                                        |
| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。                                                                         |
| \    | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。                                           |
| {    | 标记限定符表达式的开始。要匹配 {，请使用 \{。                                                                                                            |
| \|   | 指明两项之间的一个选择。要匹配 \| ，请使用 \\\|。                                                                                                        |

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 \* 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共 6 种。

正则表达式的限定符有：

| 字符  | 描述                                                                                                                                                                      |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \*    | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。                                                                                             |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。                                                                         |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。                                                  |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。                                                                   |
| {n,}  | n 是一个非负整数。至少匹配 n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o\*'。                      |
| {n,m} | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

### 定位符

| 字符 | 描述                                                                                                  |
| ---- | ----------------------------------------------------------------------------------------------------- |
|   ^  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
|  $   | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个字边界，即字与空格间的位置。                                                                  |
| \B   | 非字边界匹配。                                                                                        |

**注意：不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^\* 之类的表达式。**

是不是这么一大段的字符，已经退却了呢，没关系，我们从每一个字符入手，来这些字符是怎么匹配，怎么来完成复杂的匹配任务的。下面是每一个元字符的示意及对应实例。

## 元字符 "\\"

	
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
我们通常用"\"来做转义，我们有很多的关键字不能够直接匹配，这时候我们就需要转义符来匹配。

## 元字符 "^"

匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。如存在这样的字符串 `const str = 'one two onea oneb onec aone`我们的匹配规则是`^one`的话，那我们会获得`one`这个字符串，并且只有one，因为^是匹配我们传入字符串的起始位置开始后面跟着的字符串，并不是`oneb onea`,

## 元字符 "$"

匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。这是匹配以$之前的符号结尾的字符串，如`const str = 'one two onea oneb onec aone`，我们的匹配规则是`aone$`的话，那么就是匹配到了结尾的aone。

## 元字符 "*"
	
匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。`const str = 'one two onea oneb onec aone`，我们的匹配规则是`on*`的话,那么匹配到的就是one的on,two的o，onea的on等等。因为*代表可以没有，也可以有多个。

## 元字符 "+"

匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。`const str = 'one two onea oneb onn onnn`，我们的匹配规则是`on+`的话,那么匹配到的就是one的on,onea的on,onn,onnn。因为+代表一个，也可以有多个。

## 元字符 "?"

匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
这个相当于三元操作符的"?"，代表有还是没有。`const str = 'one two onea oneb onn onnn`，我们的匹配规则是`on?`的话,那么匹配到的就是one的on,onea的on,onn,onnn。能匹配on和o，其他的都匹配不了。